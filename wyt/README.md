# R-type 数据通路

我是在 jbz 的基础上进行的修改，修改的部分用黄色标出。

HILO 寄存器不放在寄存器文件里，而是单独拿出来放在 ALU 旁边，直接与 ALU 交互。

位扩展单元被整合到 ALU 里了，确保传到 EX 段的 imm 要是 0 扩展的才行。

乘法和除法指令目前的设计是完全暂停流水线（但要保证 EX 段寄存器值不变）直到指令执行结束，不过也可以考虑单独拿出一个乘法除法单元，让不冲突的指令继续执行。

|  指令   | Op[31:26]  | funct[5:0] |
| :-----: | :--------: | :--------: |
|   ADD   |   000000   |   100000   |
|  ADDU   |   000000   |   100001   |
|   SUB   |   000000   |   100010   |
|  SUBU   |   000000   |   100011   |
|   SLT   |   000000   |   101010   |
|  SLTU   |   000000   |   101011   |
|   DIV   |   000000   |   011010   |
|  DIVU   |   000000   |   011011   |
|  MULT   |   000000   |   011000   |
|  MULTU  |   000000   |   011001   |
|   AND   |   000000   |   100100   |
|   NOR   |   000000   |   100111   |
|   OR    |   000000   |   100101   |
|   XOR   |   000000   |   100110   |
|  SLLV   |   000000   |   000100   |
| **SLL** | **000000** | **000000** |
|  SRAV   |   000000   |   000111   |
| **SRA** | **000000** | **000011** |
|  SRLV   |   000000   |   000110   |
| **SRL** | **000000** | **000010** |
|  ADDI   |   001000   |     -      |
|  ADDIU  |   001001   |     -      |
|  SLTI   |   001010   |     -      |
|  SLTIU  |   001011   |     -      |
|  ANDI   |   001100   |     -      |
|   LUI   |   001111   |     -      |
|   ORI   |   001101   |     -      |
|  XORI   |   001110   |     -      |

不加粗的指令分为两类：非立即数指令都需要 ALU
Control 根据 funct 生成 ALUOp，且计算结果均存到 Rd；立即数指令均将结果存到 Rt。

加粗的指令是立即数的移位指令，需要把 imm 放到 ALU_a ，Rt 放到 ALU_b，同时结果存到 Rd，对应数据通路要加一个多选器。

旁路似乎不用动？

# ALU

ALU 是 EX 模块的子模块，ALUOp 由控制单元根据指令字生成。

ALU 分为三个部分：

- alu 模块，进行乘法和除法以外的所有运算，是纯组合逻辑。

- multiplier 是一个乘法器 ip 核的例化，一次乘法运算需要 5 个周期完成。
- divider 是一个除法器 ip 核的例化，一次除法运算需要 34 个周期完成。（这两个周期数都可以调整）

ALU 支持的指令及对应结果：

|   指令    |                     result                      |          hi           |          lo          |                     exception                     |
| :-------: | :---------------------------------------------: | :-------------------: | :------------------: | :-----------------------------------------------: |
|    ADD    |                       a+b                       |           -           |          -           | overflow = (a[31] ~^ b[31]) & (a[31] ^ res_1[31]) |
|   ADDI    |               a+$signed(b[15:0])                |           -           |          -           | overflow = (a[31] ~^ b[31]) & (a[31] ^ res_1[31]) |
|   ADDU    |                       a+b                       |           -           |          -           |                         -                         |
|   ADDIU   |               a+$signed(b[15:0])                |           -           |          -           |                         -                         |
|    SUB    |                       a-b                       |           -           |          -           | overflow = (a[31]  ^ b[31]) & (a[31] ^ res_1[31]) |
|   SUBU    |                       a-b                       |           -           |          -           |                         -                         |
|    SLT    |    \$signed(a) < ​\$signed(b) ? 32'd1 : 32'd0    |           -           |          -           |                         -                         |
|   SLTI    | \$signed(a) < ​\$signed(b[15:0]) ? 32'd1 : 32'd0 |           -           |          -           |                         -                         |
|   SLTU    |              a < b? 32'd1 : 32'd0               |           -           |          -           |                         -                         |
|   SLTIU   |      a < $signed(b[15:0]) ? 32'd1 : 32'd0       |           -           |          -           |                         -                         |
|    DIV    |                        -                        |     $signed(a//b)     |     $signed(a%b)     |                divZero = (b == 0)                 |
|   DIVU    |                        -                        |         a//b          |         a%b          |                divZero = (b == 0)                 |
|   MULT    |                        -                        | ($signed(a*b))[63:32] | ($signed(a*b))[31:0] |                         -                         |
|   MULTU   |                        -                        |     (a*b)[63:32]      |     (a*b)[31:0]      |                         -                         |
| AND,ANDI  |                       a&b                       |           -           |          -           |                         -                         |
|    LUI    |                 {b[15:0],16'b0}                 |           -           |          -           |                         -                         |
|    NOR    |                     ~(a\|b)                     |           -           |          -           |                         -                         |
|  OR,ORI   |                      a\|b                       |           -           |          -           |                         -                         |
| XOR,XORI  |                       a^b                       |           -           |          -           |                         -                         |
| SLLV,SLL  |                   b << a[4:0]                   |           -           |          -           |                         -                         |
| SRAV,SRA  |              $signed(b) >>> a[4:0]              |           -           |          -           |                         -                         |
| SRLV,SRL  |                   b >> a[4:0]                   |           -           |          -           |                         -                         |
|   BREAK   |                        -                        |           -           |          -           |                     break = 1                     |
|  SYSCALL  |                        -                        |           -           |          -           |                    syscall = 1                    |
| LB,LBU,SB |               a+$signed(b[15:0])                |           -           |          -           |                         -                         |
| LH,LHU,SH |               a+$signed(b[15:0])                |           -           |          -           |            addrErr = (res_1[0]==1'b1)             |
|   LW,SW   |               a+$signed(b[15:0])                |           -           |          -           |           addrErr = (res_1[1:0]!=2'b00)           |
|   MFHI    |                       hi                        |           -           |          -           |                         -                         |
|   MFLO    |                       lo                        |           -           |          -           |                         -                         |
|   MTHI    |                        -                        |           a           |          -           |                         -                         |
|   MTLO    |                        -                        |           -           |          a           |                         -                         |
|   ERET    |                        -                        |           -           |          -           |                     eret = 1                      |


问题：

- beq 指令放在 ID 段执行？
- 计算乘法和除法时，怎么 stall 流水线？是不是要搞两个 ALU ？
- 访存指令要有额外的模块做虚实地址转换。‘
- 协处理器相关的指令没写。
- lw 用不用判断地址溢出？
- 负数除法的余数和被除数同号。

- 乘法除法和数据移动指令同时完成怎么办？