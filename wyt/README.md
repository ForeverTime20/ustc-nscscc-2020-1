# EX 段

### 输入部分

|    变量名     |  位宽  |          功能          |
| :-----------: | :----: | :--------------------: |
|      clk      |   1    |        全局时钟        |
|      rst      |   1    |        全局复位        |
|  hiloWrite_i  |   1    |    空传 HILO 写使能    |
| MemReadType_i | [1:0]  |    空传 RAM 读选择     |
|  RegWrite_i   |   1    |   空传寄存器堆写使能   |
|  MemtoReg_i   |   1    |      空传写回选择      |
|  MemWrite_i   |   1    |    空传 RAM 写使能     |
|  ALUControl   | [5:0]  |         ALUop          |
|    ALUSrcA    |   1    |   选 a 是 A 或立即数   |
|    ALUSrcB    |   1    |   选 b 是 B 或立即数   |
|    RegDst     |   1    |    选写回 Rt 或 Rd     |
|    ImmSel     |   1    | 选立即数是 PC+8 或 Imm |
|   ForwardA    | [1:0]  |      选 A 的旁路       |
|   ForwardB    | [1:0]  |      选 B 的旁路       |
|       A       | [31:0] |       Rs 的内容        |
|       B       | [31:0] |       Rt 的内容        |
|    PCplus8    | [31:0] |          PC+8          |
|      Rt       | [6:0]  |           Rt           |
|      Rd       | [6:0]  |           Rd           |
|      Imm      | [31:0] |   0 扩展的 ins[15:0]   |
|  ForwardMEM   | [31:0] |   来自 MEM 段的旁路    |
|   ForwardWB   | [31:0] |    来自 WB 段的旁路    |

### 输出部分

| 变量名 | 位宽 | 功能 |
| :----: | :--: | :--: |
| hiloWrite_o |   1    |    空传 HILO 写使能    |
| MemReadType_o | [1:0]  |    空传 RAM 读选择     |
|  RegWrite_o  |   1    |   空传寄存器堆写使能   |
|  MemtoReg_o  |   1    |      空传写回选择      |
|  MemWrite_o  |   1    |    空传 RAM 写使能     |
| hiloData | [63:0] | 乘除法计算结果 |
| ALUResult | [31:0] | 其他运算结果 |
| done | 1 | 是否算出结果 |
| exception | [2:0] | 异常 |
| stall | 1 | 是否暂停流水线 |
| MemAddress | [31:0] | RAM 地址 |
| WriteRegister | [6:0] | 写回的寄存器号 |

# Decoder

ID 段的指令分解单元。

### 输入部分
| 变量名 |  位宽  |   功能   |
| :----: | :----: | :------: |
|  ins   | [31:0] | 完整指令 |

### 输出部分
|   变量名   |  位宽  |    功能     |
| :--------: | :----: | :---------: |
| ALUControl | [5:0]  |    ALUop    |
|     Rs     | [6:0]  | Read_addr_1 |
|     Rt     | [6:0]  | Read_addr_2 |
|     Rd     | [6:0]  | Write_addr  |
|    imm     | [15:0] |  ins[15:0]  |
| exception  |   1    | 指令无效为1 |

这东西应该和控制单元一起放到 ID 段，R 类指令和访存指令的 ALUop 根据指令类型即可确定，涉及 PC+8 的指令等效成 addi ，其余指令等效成 add 。

对于格式不对的指令，会触发无效异常。

Rs ， Rt ，Rd 是映射到 7 位寄存器的新寄存器号，映射规则如下：

- 常规寄存器：[6:0] = {2'b00, [4:0]}
- CP0 寄存器：[6:0] = {2'b01, [4:0]} （先不考虑 sel ）
- HI 寄存器：7'b1111111，LO 寄存器：7'b1000000

### R-type 指令

| 指令  | Op[31:26] | funct[5:0] |  额外约束   |
| :---: | :-------: | :--------: | :---------: |
|  ADD  |  000000   |   100000   | [10:6] = 0  |
| ADDU  |  000000   |   100001   | [10:6] = 0  |
|  SUB  |  000000   |   100010   | [10:6] = 0  |
| SUBU  |  000000   |   100011   | [10:6] = 0  |
|  SLT  |  000000   |   101010   | [10:6] = 0  |
| SLTU  |  000000   |   101011   | [10:6] = 0  |
|  DIV  |  000000   |   011010   | [15:6] = 0  |
| DIVU  |  000000   |   011011   | [15:6] = 0  |
| MULT  |  000000   |   011000   | [15:6] = 0  |
| MULTU |  000000   |   011001   | [15:6] = 0  |
|  AND  |  000000   |   100100   | [10:6] = 0  |
|  NOR  |  000000   |   100111   | [10:6] = 0  |
|  OR   |  000000   |   100101   | [10:6] = 0  |
|  XOR  |  000000   |   100110   | [10:6] = 0  |
| SLLV  |  000000   |   000100   | [10:6] = 0  |
|  SLL  |  000000   |   000000   | [25:21] = 0 |
| SRAV  |  000000   |   000111   | [10:6] = 0  |
|  SRA  |  000000   |   000011   | [25:21] = 0 |
| SRLV  |  000000   |   000110   | [10:6] = 0  |
|  SRL  |  000000   |   000010   | [25:21] = 0 |
| ADDI  |  001000   |     -      |      -      |
| ADDIU |  001001   |     -      |      -      |
| SLTI  |  001010   |     -      |      -      |
| SLTIU |  001011   |     -      |      -      |
| ANDI  |  001100   |     -      |      -      |
|  LUI  |  001111   |     -      | [25:21] = 0 |
|  ORI  |  001101   |     -      |      -      |
| XORI  |  001110   |     -      |      -      |

### 访存指令

| 指令 | Op[31:26] |
| :--: | :-------: |
|  LB  |  100000   |
| LBU  |  100100   |
|  LH  |  100001   |
| LHU  |  100101   |
|  LW  |  100011   |
|  SB  |  101000   |
|  SH  |  101001   |
|  SW  |  101011   |

### Jump 指令


| 指令 | Op[31:26] | funct[5:0] |     额外约束     |       等效指令       |
| :--: | :-------: | :--------: | :--------------: | :------------------: |
|  J   |  000010   |     -      |        -         |     add #0,Rs,Rt     |
| JAL  |  000011   |     -      |        -         | **addi #31,#0,PC+8** |
|  JR  |  000000   |   001000   |     [20:6]=0     |     add #0,Rs,Rt     |
| JALR |  000000   |   001001   | [20:16]=[10:6]=0 | **addi Rd,#0,PC+8**  |

*虽然是 addi ，但是 ALUop 要是 add ，因为不能做位扩展。

*对于 JALR ，虽然读寄存器堆用的 Rs 不为 0 ，但做等效指令往后传的 Rs 必须为0 ，我想到一个办法就是针对 JALR 生成特定的选择信号，让 ALU_a 选 imm，ALU_b 选 Rt ，这样就和立即数移位一样了，由于 ins[20:16] 为 0 ，故 Rt = 0 ，即对于加粗的指令，ALU 计算的结果为 Rt + (PC+8)，存回 Rd 。

### Branch 指令

|  指令  | Op[31:26] | funct[20,16] | 额外约束  |       等效指令       |
| :----: | :-------: | :----------: | :-------: | :------------------: |
|  BEQ   |  000100   |      -       |     -     |     add #0,Rs,Rt     |
|  BNE   |  000101   |      -       |     -     |     add #0,Rs,Rt     |
|  BGTZ  |  000111   |      -       |     -     |     add #0,Rs,Rt     |
|  BLEZ  |  000110   |      -       |     -     |     add #0,Rs,Rt     |
|  BGEZ  |  000001   |     0,1      | [19:17]=0 |     add #0,Rs,Rt     |
|  BLTZ  |  000001   |     0,0      | [19:17]=0 |     add #0,Rs,Rt     |
| BGEZAL |  000001   |     1,1      | [19:17]=0 | **addi #31,#0,PC+8** |
| BLTZAL |  000001   |     1,0      | [19:17]=0 | **addi #31,#0,PC+8** |

*后两类指令事实上没有用到 Rt ，所以可以直接让 Rt = 0 ，然后同上处理。

### 数据移动指令

| 指令 | Op[31:26] | funct[5:0] |     额外约束     |   等效指令   |
| :--: | :-------: | :--------: | :--------------: | :----------: |
| MFHI |  000000   |   010000   | [25:16]=[10:6]=0 | add rd,HI,#0 |
| MFLO |  000000   |   010010   | [25:16]=[10:6]=0 | add rd,LO,#0 |
| MTHI |  000000   |   010001   |      [20:6]      | add HI,Rs,#0 |
| MTLO |  000000   |   010011   |      [20:6]      | add LO,Rs,#0 |

### 自陷指令

|  指令   | Op[31:26] | funct[5:0] |
| :-----: | :-------: | :--------: |
|  BREAK  |  000000   |   001101   |
| SYSCALL |  000000   |   001100   |

### 特权指令

|   指令   | Op[31:26] | funct[25:21] |       额外约束        |       等效指令        |
| :------: | :-------: | :----------: | :-------------------: | :-------------------: |
| **ERET** |  010000   |    10000     | [20:6]=0,[5:0]=011000 |           -           |
|   MFC0   |  010000   |    00000     |       [10:0]=0        | add Rt,#0,{2'b01, rd} |
|   MTC0   |  010000   |    00100     |       [10:0]=0        | add {2'b01, rd},#0,Rt |

*EPC 从寄存器文件里出来是啥意思？

# R-type 数据通路

我是在 jbz 的基础上进行的修改，修改的部分用黄色标出。

位扩展单元被整合到 ALU 里了，确保传到 EX 段的 imm 要是 0 扩展的才行。

乘法和除法指令需要 stall 流水线直到结果算出。

立即数的移位指令，需要把 imm 放到 ALU_a ，Rt 放到 ALU_b，同时结果存到 Rd，对应数据通路要加一个多选器。

# ALU

ALU 是 EX 模块的子模块，ALUOp 由控制单元根据指令字生成。

ALU 分为三个部分：

- alu 模块，进行乘法和除法以外的所有运算，是纯组合逻辑。

- multiplier 是一个乘法器 ip 核的例化，一次乘法运算需要 5 个周期完成。
- divider 是一个除法器 ip 核的例化，一次除法运算需要 34 个周期完成。（这两个周期数都可以调整）

ALU 支持的指令及对应结果：

|   指令    |                     result                      |          hi           |          lo          |                     exception                     |
| :-------: | :---------------------------------------------: | :-------------------: | :------------------: | :-----------------------------------------------: |
|    ADD    |                       a+b                       |           -           |          -           | overflow = (a[31] ~^ b[31]) & (a[31] ^ res_1[31]) |
|   ADDI    |               a+$signed(b[15:0])                |           -           |          -           | overflow = (a[31] ~^ b[31]) & (a[31] ^ res_1[31]) |
|   ADDU    |                       a+b                       |           -           |          -           |                         -                         |
|   ADDIU   |               a+$signed(b[15:0])                |           -           |          -           |                         -                         |
|    SUB    |                       a-b                       |           -           |          -           | overflow = (a[31]  ^ b[31]) & (a[31] ^ res_1[31]) |
|   SUBU    |                       a-b                       |           -           |          -           |                         -                         |
|    SLT    |    \$signed(a) < ​\$signed(b) ? 32'd1 : 32'd0    |           -           |          -           |                         -                         |
|   SLTI    | \$signed(a) < ​\$signed(b[15:0]) ? 32'd1 : 32'd0 |           -           |          -           |                         -                         |
|   SLTU    |              a < b? 32'd1 : 32'd0               |           -           |          -           |                         -                         |
|   SLTIU   |      a < $signed(b[15:0]) ? 32'd1 : 32'd0       |           -           |          -           |                         -                         |
|    DIV    |                        -                        |     $signed(a//b)     |     $signed(a%b)     |                divZero = (b == 0)                 |
|   DIVU    |                        -                        |         a//b          |         a%b          |                divZero = (b == 0)                 |
|   MULT    |                        -                        | ($signed(a*b))[63:32] | ($signed(a*b))[31:0] |                         -                         |
|   MULTU   |                        -                        |     (a*b)[63:32]      |     (a*b)[31:0]      |                         -                         |
| AND,ANDI  |                       a&b                       |           -           |          -           |                         -                         |
|    LUI    |                 {b[15:0],16'b0}                 |           -           |          -           |                         -                         |
|    NOR    |                     ~(a\|b)                     |           -           |          -           |                         -                         |
|  OR,ORI   |                      a\|b                       |           -           |          -           |                         -                         |
| XOR,XORI  |                       a^b                       |           -           |          -           |                         -                         |
| SLLV,SLL  |                   b << a[4:0]                   |           -           |          -           |                         -                         |
| SRAV,SRA  |              $signed(b) >>> a[4:0]              |           -           |          -           |                         -                         |
| SRLV,SRL  |                   b >> a[4:0]                   |           -           |          -           |                         -                         |
|   BREAK   |                        -                        |           -           |          -           |                     break = 1                     |
|  SYSCALL  |                        -                        |           -           |          -           |                    syscall = 1                    |
| LB,LBU,SB |               a+$signed(b[15:0])                |           -           |          -           |                         -                         |
| LH,LHU,SH |               a+$signed(b[15:0])                |           -           |          -           |            addrErr = (res_1[0]==1'b1)             |
|   LW,SW   |               a+$signed(b[15:0])                |           -           |          -           |           addrErr = (res_1[1:0]!=2'b00)           |
|   ERET    |                        -                        |           -           |          -           |                     eret = 1                      |


问题：

- beq 指令放在 ID 段执行？
- 计算乘法和除法时，怎么 stall 流水线？是不是要搞两个 ALU ？
- 访存指令要有额外的模块做虚实地址转换。‘
- 协处理器相关的指令没写。
- lw 用不用判断地址溢出？
- 负数除法的余数和被除数同号。

- 乘法除法和数据移动指令同时完成怎么办？